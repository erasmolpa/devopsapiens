---
title: "Introduccion a la IaC. Ideas y Principios"
date: 2024-05-13
last_modified_at: 2024-05-13
cat:
  - IaC
  - post-series
---

# Introducción:

Aunque cada vez menos frecuentemente, he participado en numerosas conversaciones donde se busca resolver problemas técnicos centrándose en la elección de herramientas. En este contexto, el verdadero problema se pierde entre disputas sobre qué herramienta es mejor.

Estas discusiones son cruciales, pero no deberían ser el primer paso. En el mundo de la infraestructura como código (IaC), he sido testigo de innumerables batallas donde se elige la herramienta antes de entender realmente el problema.

En este primer post,(pretendo que esto sea una serie de post), vamos a poner en contexto que es la IaC y nos centrareos en hablar de algunos principios y recomendaciones.


## El Problema:

Independientemente de tu rol o experiencia en el mundo de la tecnología, es bastante probable que en algún punto de tu carrera, y con más frecuencia de la que te gustaría, hayas tenido que lidiar con la frustrante labor de aprovisionar o configurar infraestructura.

Si eres desarrollador, y por mucho que puedas decir eso de ; "en mi local funciona", seguro que no estás excento de alguna que otra batalla contra la máquina.

La infraestructura ha evolucionado desde servidores físicos, pasando por virtualización, el paso a la nube, e incluso a los clústeres de Kubernetes. Esta evolución ha hecho que la tarea de aprovisionar y configurar la infraestructura sea cada vez más desafiante.

El problema a resolver radica en la creciente complejidad de gestionar la infraestructura a medida que ha ido mutando continuamente.

## La solución:

IaC: "Enfoque que permite crear y configurar recursos de infraestructura de manera programática"

¿Pero esto no ya está cubierto con scripting? ¿O mejor aún, por qué complicarme la vida si puedo hacerlo manualmente?

Infrastructure as Code (IaC) ofrece una solución a estos desafíos. Es una metodología que permite definir, implementar y gestionar la infraestructura de TI utilizando código. En lugar de realizar cambios manualmente en la infraestructura en la nube, podemos escribir código que describa esos recursos y su configuración, y luego utilizar herramientas especializadas para implementar y mantener esa infraestructura de manera automatizada, consistente y, sobre todo, idempotente.

IaC nos permite tratar la infraestructura como código, aplicando los principios de desarrollo de software a la gestión de la infraestructura. Esto significa que podemos aprovechar las prácticas de desarrollo ágil, como la integración continua y la entrega continua, para iterar rápidamente en nuestra infraestructura y responder de manera eficiente a los cambios en los requisitos del negocio.


# Principios

- **Idempotencia:** _no quiero sorpresas_

Es la propiedad de una operación en la que su aplicación repetida no produce cambios adicionales más allá del primer efecto. En el contexto de IaC, la idempotencia implica que la ejecución repetida del código de infraestructura no cause efectos secundarios no deseados. Por ejemplo, si aplicamos un script de aprovisionamiento varias veces, solo se implementarán los cambios necesarios, evitando la duplicación de recursos o la alteración de configuraciones existentes.

Ejemplo: Supongamos que queremos asegurarnos de que un archivo de configuración esté presente en un servidor. Utilizaremos un comando bash para copiar este archivo desde una ubicación remota a nuestro servidor.

```bash
scp user@remote_host:/path/to/config_file.txt /path/to/local_directory/
```

Si ejecutamos este comando varias veces, el archivo se copiará solo una vez, y las ejecuciones posteriores no tendrán ningún efecto adicional, ya que el archivo ya estará presente en la ubicación especificada. No se crearán copias adicionales del archivo, lo que demuestra la propiedad idempotente del comando.

- **Reusabilidad:** _Eso que acabas de hacer..Podrías repetirlo?_ 
  
Se refiere a la capacidad de repetir un proceso o una acción de manera consistente y predecible. En el contexto de IaC, la repeatabilidad implica que al desplegar la misma configuración varias veces, se obtendrán los mismos resultados en cada instancia. Esto asegura que los entornos y configuraciones sean reproducibles, lo que facilita la creación de entornos consistentes y la corrección de errores de manera eficiente

Ejemplo: Con el ejemplo anterior, siempre que ejecutemos ese comando, obtendremos el mismo resultado, es decir, el archivo de configuración se copiará desde la ubicación remota al directorio local especificado. Esto asegura que el proceso sea repetible, 

- **Consistencia:**

 Se refiere a la uniformidad y coherencia en la configuración y el comportamiento de los recursos de infraestructura. En el contexto de IaC, la consistencia implica que los entornos y configuraciones sean reproducibles y predecibles. Por ejemplo, si desplegamos la misma configuración varias veces, esperamos obtener los mismos resultados en cada instancia.

**Ejemplo:** verifique si el archivo de configuración ya existe en la ubicación local antes de intentar copiarlo nuevamente. Esto garantizará que la configuración en el servidor sea consistente y evitará la duplicación de archivos.

```bash
# Comprobar si el archivo de configuración ya existe en la ubicación local
if [ -f /path/to/local_directory/config_file.txt ]; then
    echo "El archivo de configuración ya existe en el servidor."
else
    # Copiar el archivo de configuración desde una ubicación remota al servidor
    scp user@remote_host:/path/to/config_file.txt /path/to/local_directory/
    echo "Se ha copiado el archivo de configuración al servidor."
fi
```

cada vez que ejecutamos el script, se verificará si el archivo de configuración ya está presente en el servidor local. Si ya existe, el script mostrará un mensaje indicando que el archivo ya está allí. Si no existe, se copiará el archivo desde la ubicación remota al servidor local. 

- **Transparencia:** 
  
  La transparencia en IaC implica tener visibilidad y comprensión del estado y la configuración de los recursos en la nube en todo momento.

- **Estabilidad:** _"no tengo miedo a cambiar"_ 
  
  La estabilidad en IaC no significa inmovilidad, sino la capacidad de implementar cambios de manera segura y controlada en tu infraestructura en la nube.

- **Efimera:** _"no te necesito"_ 
  
  Con IaC, podemos generar y recrear recursos en la infraestructura en la nube de manera automatizada, eliminando la necesidad de intervención manual en cada paso del proceso.


## Consejos:

- **Elige bien tus Armas:** 
  
  _La ergonomía, el lenguaje y el comportamiento si son importantes, pero no es el Todo_

Elegir armas es importante. Igual te encantan las espadas ninjas, pero ¿con qué cortarías leña?

En IaC pasa algo similar, a veces nos enfrascamos en elegir el arma que nos encanta por su ergonomía, ligereza, porque nos hace sentir flexibles y poderosos... pero esto no va solo de eso.

Algunas de las características a tener en cuenta a la hora de elegir el lenguaje son las siguientes:

Declarativa vs Imperativa: Igual me animo a escribir un post solo para hablar de esta característica, porque da para eso y más. Pero digamos que se trata de cómo quieres expresarte.
Declarativo (enfocado en el QUÉ). Basado en modelar el sistema.
Imperativo (enfocado en el CÓMO). Basado en proceso.
Mutable vs Inmutable
Push vs Pull
Estas son características con un enfoque comparativo que te pueden dar pistas sobre qué camino escoger en cuanto a la elección de las herramientas. Pero hay otras que no son tan mencionadas y que me gustaría añadir a continuación:

Ergonomía del Lenguaje: Si tu idea es cortar leña, coge el hacha y deja la espada ninja para tus ratos libres.
Gestión del Ciclo de Vida: Es un factor que normalmente se estudia y se aborda a posteriori, una vez se ha elegido la herramienta principal, pero que es importante tener en cuenta antes. Al menos entender los modelos y las implicaciones. Cómo se aplican los cambios y qué mecanismos disponemos para actualizar y reconciliar los estados de nuestros recursos.

Entender la complejidad implícita y explícita de la infraestructura nos ayuda a organizar y estructurar el código de manera más efectiva.
Nota: Lo más normal es que tu solución de IaC final esté compuesta por un conjunto de herramientas e incluso algún que otro script para poder abordar todos tus problemas.

- **Se pragmático:** 

_el código de infraestructura es fuego real_

Tratar de transcibir scripts y procesos actuales para tu Infra a la herramienta/as de turno de IaC no será suficiente. 

> Ejemplo de código:

```pulumi 
import * as aws from '@pulumi/aws'
import * as pulumi from '@pulumi/pulumi'
import * as pulumi_k8s from '@pulumi/kubernetes'

// Retrieve configurations
const kloConfig = new pulumi.Config('klo')
const protect = kloConfig.getBoolean('protect') ?? false
const awsConfig = new pulumi.Config('aws')
const awsProfile = awsConfig.get('profile')
const accountId = pulumi.output(aws.getCallerIdentity({}))
const region = pulumi.output(aws.getRegion({}))

// Create Elastic IP addresses for NAT gateways
const subnet_0_route_table_nat_gateway_elastic_ip = new aws.ec2.Eip("subnet-0-route_table-nat_gateway-elastic_ip", {
    tags: {GLOBAL_KLOTHO_TAG: "", RESOURCE_NAME: "subnet-0-route_table-nat_gateway-elastic_ip"},
})
const subnet_1_route_table_nat_gateway_elastic_ip = new aws.ec2.Eip("subnet-1-route_table-nat_gateway-elastic_ip", {
    tags: {GLOBAL_KLOTHO_TAG: "", RESOURCE_NAME: "subnet-1-route_table-nat_gateway-elastic_ip"},
})

// Create IAM role for EKS cluster
const clusterrole_eks_cluster_0 = new aws.iam.Role("ClusterRole-eks_cluster_0", {
    assumeRolePolicy: pulumi.jsonStringify({Statement: [{Action: ["sts:AssumeRole"], Effect: "Allow", Principal: {Service: ["eks.amazonaws.com"]}}], Version: "2012-10-17"}),
    managedPolicyArns: [
        ...["arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"],
    ],
    tags: {GLOBAL_KLOTHO_TAG: "", RESOURCE_NAME: "ClusterRole-eks_cluster_0"},
})

// Create VPC
const vpc_0 = new aws.ec2.Vpc("vpc-0", {
    cidrBlock: "10.0.0.0/16",
    enableDnsHostnames: true,
    enableDnsSupport: true,
    tags: {GLOBAL_KLOTHO_TAG: "", RESOURCE_NAME: "vpc-0"},
})

// Create Internet Gateway
const internet_gateway_0 = new aws.ec2.InternetGateway("internet_gateway-0", {
    vpcId: vpc_0.id,
    tags: {GLOBAL_KLOTHO_TAG: "", RESOURCE_NAME: "internet_gateway-0"},
})

// Create EKS cluster security group
const eks_cluster_0_security_group = new aws.ec2.SecurityGroup("eks_cluster_0-security_group", {
    name: "eks_cluster_0-security_group",
    vpcId: vpc_0.id,
    egress: [{cidrBlocks: ["0.0.0.0/0"], description: "Allows all outbound IPv4 traffic", fromPort: 0, protocol: "-1", toPort: 0}],
    ingress: [{cidrBlocks: ["0.0.0.0/0"], description: "Allows ingress traffic from the EKS control plane", fromPort: 9443, protocol: "TCP", toPort: 9443}, {description: "Allow ingress traffic from within the same security group", fromPort: 0, protocol: "-1", self: true, toPort: 0}],
    tags: {GLOBAL_KLOTHO_TAG: "", RESOURCE_NAME: "eks_cluster_0-security_group"},
})

// More resource creation...

// Create EKS cluster
const eks_cluster_0 = new aws.eks.Cluster("eks_cluster_0", {
    version: "1.28",
    vpcConfig: {
        subnetIds: [subnet_0, subnet_1].map((subnet) => subnet.id),
        securityGroupIds: [eks_cluster_0_security_group].map((sg) => sg.id),
    },
    roleArn: clusterrole_eks_cluster_0.arn,
    tags: {GLOBAL_KLOTHO_TAG: "", RESOURCE_NAME: "eks_cluster_0"},
})

// More resource creation...

// Generate kubeconfig
const kube_config_eks_cluster_0_kube_config = pulumi.jsonStringify({
    apiVersion: "v1",
    clusters: [
        {
            name: eks_cluster_0.name,
            cluster: {
                "certificate-authority-data": eks_cluster_0.certificateAuthorities[0].data,
                "server": eks_cluster_0.endpoint,
            },
        },
    ],
    contexts: [{context: {cluster: eks_cluster_0.name, user: eks_cluster_0.name}, name: eks_cluster_0.name}],
    'current-context': eks_cluster_0.name,
    kind: "Config",
    users: [{name: eks_cluster_0.name, user: {exec: {apiVersion: "client.authentication.k8s.io/v1beta1", args: ["eks", "get-token", "--cluster-name", eks_cluster_0.name, "--region", region_0.apply((o) => o.name)], command: "aws"}}}],
})

// Create Kubernetes provider
const kubernetes_provider_eks_cluster_0_kube_config = new pulumi_k8s.Provider("eks_cluster_0-kube_config", {
    kubeconfig: kube_config_eks_cluster_0_kube_config,
})

````

Seguramente si estás familiarizado a escribir codigo y si te digo que pretendo usar este codigo como la base para crear los clusters e EKS de nuestra compañía , te estés 
 
- **Divide y vencerás:** 

> El coste de refactorizar/cambiar algo es alto

> Las pruebas son duras, y no negociables



Espero que te halla gustado este post. En realidad pretendo convertirlo en una serie de post en la que iré tirando del hilo de todos los puntos tratados en esta intro , ya que como podras imaginar, hay mucha tela que cortar. 


¡Gracias por leer!

